---
title: "Week 2 Exercises"
author: "Kaylynn Hiller"
date: "2026-01-20"
mainfont: "Georgia"
format: 
  html: 
    theme: cosmo
    toc: true
    embed-resources: true
  pdf:
    colorlinks: true
    includes:
      in-header:
    keep-tex: true
header-includes:
  \usepackage{tabularray}
  \usepackage{siunitx}
execute: 
  echo: false
---

## Week 2

```{r}

library(nycflights13)
library(tidyverse)
```

**Exercise 3.2.5**

1.  In a single pipeline for each condition, find all flights that meet the condition:

-   Had an arrival delay of two or more hours

```{r}
flights |> 
  filter(arr_delay >= 120)
```

-   Flew to Houston (`IAH` or `HOU`)

```{r}
flights |> 
  filter(dest == "IAH" | dest == "HOU")
```

-   Were operated by United, American, or Delta

```{r}
flights |> 
  filter(carrier %in% c("UA", "AA", "DL"))
```

-   Departed in summer (July, August, and September)

```{r}
flights |> 
  filter(month %in% 7:9)
```

-   Arrived more than two hours late but didn’t leave late

```{r}
flights |> 
  filter(arr_delay > 120 & dep_delay <= 0)
```

-   Were delayed by at least an hour, but made up over 30 minutes in flight

```{r}
flights |> 
  filter(dep_delay >= 60 & dep_delay - arr_delay > 30)
```

2.  Sort flights to find the flights with the longest departure delays. Find the flights that left earliest in the morning.

```{r}
flights |> 
  arrange(desc(dep_delay))

flights |> 
  arrange(dep_time)
```

3.  Sort flights to find the fastest flights. (Hint: Try including a math calculation inside of your function.)

```{r}
to_kmh <- function(distance, minutes) {
  (distance * 1.60934) / (minutes / 60)
}

flights |> 
  mutate(speed = to_kmh(distance, air_time)) |>
  relocate(speed) |> 
  arrange(desc(speed))
```

4.  Was there a flight on every day of 2013? Yes

```{r}
flights |> 
  distinct(month, day) |> 
  summarize(num_days = n())
```

5.  Which flights traveled the farthest distance? Which traveled the least distance?

```{r}
flights |> 
  arrange(desc(distance))

flights |> 
  arrange(distance)
```

6.  Does it matter what order you used filter() and arrange() if you’re using both? Why/why not? Think about the results and how much work the functions would have to do.

It does not matter. Filter pulls out rows that meet a condition but does not change the ordering. Arrange changes the ordering but leaves all rows in. Since they perform separate actions, the order does not matter.

**Exercise 3.3.5**

1.  Compare dep_time, sched_dep_time, and dep_delay. How would you expect those three numbers to be related?

I would expect the scheduled departure time (sched_dep_time) plus the delay (dep_delay) to equal the actual departure time (dep_time).

```{r}
flights |>
  select(dep_time, sched_dep_time, dep_delay)
```

2.  Brainstorm as many ways as possible to select dep_time, dep_delay, arr_time, and arr_delay from flights.
```{r}
flights

flights |>
  select(dep_time, dep_delay, arr_time, arr_delay)

flights |>
  select(dep_time:arr_delay)

flights |>
  select(!year:day & !sched_dep_time & !sched_arr_time &!carrier:time_hour)

flights |> 
  select(starts_with("dep_"), starts_with("arr_"))
```

3.  What happens if you specify the name of the same variable multiple times in a select() call?
```{r}
flights|>
  select(year, year)
```
You just get the variable once.

4.  What does the any_of() function do? Why might it be helpful in conjunction with this vector?
```{r}
variables <- c("year", "month", "day", "dep_delay", "arr_delay")
flights|>
  select(any_of(variables))
```
The any_of() function in conjuction with the select function selects any variables listed. If you set specific variables to select outside the pipeline, the code is cleaner and easier to change.

5.  Does the result of running the following code surprise you? How do the select helpers deal with upper and lower case by default? How can you change that default?
```{r}
flights |> select(contains("TIME"))
```
The result did not surprise me. By default, select helpers treat upper and lower case the same. You can change this by specifying with ignore.case = FALSE.

6.  Rename air_time to air_time_min to indicate units of measurement and move it to the beginning of the data frame.
```{r}
flights |>
  relocate(air_time_min = air_time)
```

7.  Why doesn’t the following work, and what does the error mean?
```{r}
#flights |> 
  #select(tailnum) |> 
  #arrange(arr_delay)
#> Error in `arrange()`:
#> ℹ In argument: `..1 = arr_delay`.
#> Caused by error:
#> ! object 'arr_delay' not found
```

We did not select the arr_delay variable in the select function so it is not available to arrange. Select keeps only the columns listed.

**Exercise 3.5.7**

1. Which carrier has the worst average delays? Challenge: can you disentangle the effects of bad airports vs. bad carriers? Why/why not? (Hint: think about...)
```{r}
flights |> 
  group_by(carrier) |> 
  summarize(avg_dep_del = mean(dep_delay, na.rm = TRUE)) |> 
  arrange(desc(avg_dep_del))

flights |> 
  filter(carrier == "F9") |> 
  count(carrier, dest, origin) 

flights |> 
  count(carrier, dest) |> 
  filter(dest == "DEN")

flights |> 
  group_by(carrier, dest, origin) |> 
  summarize(n = n(), avg_dd = mean(dep_delay, na.rm = TRUE)) |> 
  filter(dest == "DEN" | carrier == "F9") |> 
  arrange(avg_dd)
```
The carrier with the worst average delays is Frontier airlines. However, they are headquartered in Denver and this data set only includes flights from LGA to DEN. This means there’s no variance in F9 across airports since there is only one flight path being recorded. We cannot disentangle the effects of bad airports from this data set and would have to make a lot of assumptions in order to do so.

2. Find the flights that are most delayed upon departure to each destination.
```{r}
flights |>
  group_by(dest) |>
  slice_max(dep_delay) |>
  relocate(dest, carrier, dep_delay) |> 
  arrange(desc(dep_delay))
```


3. How do delays vary over the course of the day? Illustrate your answer with a plot.
```{r}
flights |> 
  group_by(hour) |> 
  filter(!is.na(dep_delay)) |> 
  summarize(
    avg = mean(dep_delay)) |> 
  ggplot(aes(hour, avg)) + 
  geom_point(color = "steelblue") +
  labs(title = "Average Departure Delays Over a 24 Hour Period", subtitle = "Using US Bureau of Transportation Statistics Data on Flights Departing from NYC in 2013", x = "Hour of Day", y = "Average Departure Delay in Minutes")

```
Delays do vary.

4. What happens if you supply a negative n to slice_min() and friends?
```{r}
flights |> 
  slice_min(dep_delay, n = -1)

flights |> 
  arrange(dep_delay)
```
The result is listing the rows based on the smallest to largest dep_delay value. This result is the same as arranging the values by dep_delay.

5. Explain what count() does in terms of the dplyr verbs you just learned. What does the sort argument to count() do?
```{r}
flights |> 
  count(origin)

flights |> 
  count(origin, sort = TRUE)
```
Count allows you to count the unique values of one or more variables similar to group_by and summarize. The sort options causes the results to be presented in descending order.

6. Suppose we have the following tiny data frame:

```{r}
df <- tibble(
  x = 1:5,
  y = c("a", "b", "a", "a", "b"),
  z = c("K", "K", "L", "L", "K")
)
```

a. Write down what you think the output will look like, then check if you were correct, and describe what group_by() does.
```{r}
df |>
  group_by(y)
```
This command should group by the two groups in y.

b. Write down what you think the output will look like, then check if you were correct, and describe what arrange() does. Also, comment on how it’s different from the group_by() in part (a).
```{r}
df |>
  arrange(y)
```
This command should arrange the results by the y column alphabetically. This means it should be list the results as a,a,a,b,b. The row order changed in using arrange() and not group_by().

c. Write down what you think the output will look like, then check if you were correct, and describe what the pipeline does.
```{r}
df |>
  group_by(y) |>
  summarize(mean_x = mean(x))
```
The result should be a summary of the mean of x based on the two groups of y. The pipeline passes the group_by() function along into the summarize() function so the means are groups by y values.

d. Write down what you think the output will look like, then check if you were correct, and describe what the pipeline does. Then, comment on what the message says.
```{r}
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x))
```
The result should be a summary of the mean of x based on the three groups of y and z (a K, a L, a K). This pipeline passes the group_by() function along into the summarize() function so the means are groups by y and z values. The message means that the results are grouped by y values first and the grouping can be overriden using the .groups argument.

e. Write down what you think the output will look like, then check if you were correct, and describe what the pipeline does. How is the output different from the one in part (d)?
```{r}
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x), .groups = "drop")
```
The answer should be the same except the results are not grouped.

f. Write down what you think the outputs will look like, then check if you were correct, and describe what each pipeline does. How are the outputs of the two pipelines different?
```{r}
df |>
  group_by(y, z) |>
  summarize(mean_x = mean(x))

df |>
  group_by(y, z) |>
  mutate(mean_x = mean(x))
```
The first pipeline calculated the means for the three combinations of the y and z column values. The second pipeline creates a new column where these means are stored. The output of the first pipeline is three rows and five rows for the second.

